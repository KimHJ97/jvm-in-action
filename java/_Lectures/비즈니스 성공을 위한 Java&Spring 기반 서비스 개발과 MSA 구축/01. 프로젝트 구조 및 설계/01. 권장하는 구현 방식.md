# 권장하는 구현 방식

## 개발 디자인 문서를 작성한 후 구현을 시작하자

서비스 구현에 대한 목표와 설계, 제약 사항 등을 미리 생각한 후에 개발을 시작한다면 큰 시행 착오 없이 원하는 구현을 진행할 수 있다.  
개발 디자인 문서를 작성한 후에 동료들과 리뷰하는 과정을 거친다면 좀 더 좋은 디자인 방향성을 잡을 수 있다.  

 - 문제 정의
    - 배경(현재 어떤 상황이고 개발로써 어떻게 해결할 것인가)
    - 필수 조건(개발 시스템의 성공 조건)
    - 목표
    - 목표가 아닌것
    - 평가
 - 해결 방안
    - 설계
    - 구현
    - 테스트
    - 코드 리뷰
    - 모니터링
    - 보안
 - 배포 계획
    - 계획
    - 배포
 - 타임라인
    - 로드맵

<br/>

## 테이블 설계를 먼저하지 말고 핵심 도메인 도출을 먼저하자

 - 테이블은 도메인 객체를 영속화하기 위한 그릇 역할로 생각하는 것이 좋다. 
    - ORM이 생기면서 테이블 중심으로 코드를 구현하던 패러다임이 진정한 객체 중심의 개발로 전환될 수 있었다.
 - 코딩을 하기 전 해야할 일
    - 개발해야 하는 주요 요구사항과 제약 사항을 감안
    - 핵심 도메인 객체 도출
    - 특수 기능을 수행하기 위해 도메인 간 주고 받아야 하는 메시지 정의

<br/>

## 변수명, 메서드명에 많은 신경을 쓰자

 - 변수명이나 메서드명을 읽었을 때 그것이 무엇을 의미하는지 빠르게 이해할 수 있도록 네이밍 하는 것이 좋다.
 - 현업에서 사용하는 보편적인 언어를 최대한 반영한다.
 - 전사 표준, 또는 프로젝트 내에서의 네이밍 규칙을 세우고 운영하는 것도 좋다.

<br/>

## API 명세에서 request와 response의 프로퍼티는 필수값만 유지되도록 한다.

 - API 설계할 때 없어도되는 request는 제거하고, 외부에 리턴하는 response도 최소한을 유지한다.
 - response의 경우 API 목적에 맞지 않는 불필요한 응답을 포함하여 제공하고, 이를 가져다 쓰는 외부 로직이 있다면 추후 해당 response의 특정 프로퍼티 제거는 어렵게 될 수 있다.

<br/>

## setter는 쓰지 않거나 최소화한다.

 - setter는 캡슐화된 도메인과 객체를 깨뜨리는 주범이 된다.
 - 도메인 객체를 생성할 때 생성자를 활용하여 필수값을 객체 생성 시에 받도록 하고, 도메인 상태를 변경할 때에는 적절한 메서드명을 가지는 상태 변경 로직을 구현하는 것이 좋다.
 - 이러한 방식은 도메인을 변경할 때 해당 도메인이 제공하는 상태 변경 로직을 호출할 수 밖에 없고, 이는 도메인 내의 정합성을 유지하는데 도움이 된다.

<br/>

## 트랜잭션의 사용과 범위 설정은 여러 번 고민 후 결정하자

 - 트랜잭션은 도메인의 데이터 정합성을 위한 필수 기능이다.
 - 다만, 서비스 성격에 따라 트랜잭션의 범위를 적절히 잡는 것이 중요하다.
 - 트랜잭션의 범위는 작게 잡는 것이 좋다.
 - 트랜잭션 내에서 외부 3rd party 서비스를 호출하는 로직이 있다면 적절한 타임아웃 설정은 필수이고, 필요에 따라서 트랜잭션 내에 포함시키지 않는 것도 고려해야 한다.

<br/>

## 도메인 객체가 무조건 DB에 저장되는 것은 아니다.

 - 모든 도메인 객체가 Repository를 통해 저장되고 관리되는 것은 아니다.
 - 테이블이 저장되지 않는 도메인 객체도 얼마든지 존재할 수 있다.
```java
// Money는 결제 서비스 전반에 사용되는 필수 파라미터이면서 도메인 객체이지만, DB에 저장되는 도메인 객체는 아니다.
// 결제 서비스에서 가격 계산과 정합성 체크는 중요한 도메인 로직이다. 떄문에, Money라는 객체 안에 해당 로직을 모아 놓았다.
@Getter
@EqualsAndHashCode
public class Money implements Comparable<Money> {
    private final BigDecimal value;
    public static final Money ZERO = Money.of(BigDecimal.ZERO);

    private Money(BigDecimal value) {
        this.value = value.setScale(0, RoundingMode.HALF_EVEN);
    }

    // ..
}
```
<br/>

## try-catch는 필요한 경우가 아니면 쓰지 말자.

 - 불필요한 try-catch는 로직 흐름을 파악하기 어렵게 하면서 코드의 양만 늘리는 주범이 된다.
 - try-catch의 사용은 Exception을 catch 했을 때 추가적인 로직 구현이 필요한 경우에만 선언한다.
 - 그 외에도 발생한 Exception을 그대로 throw 하는 것이 구현도 깔끔하고 로직 흐름에도 좋다.

<br/>

## 꼭 필요한 상태만 선언하자.

 - 도메인 객체의 상태값은 도메인의 Identity 만큼 중요한 프로퍼티다. 상태값을 통해 도메인 객체의 상태를 판별할 수 있고, 그에 따라 적절한 로직 실행이 가능하기 때문이다.
 - 다만, 너무 세분화된 상태값 구분은 해당 도메인을 이해하기 어렵게 만들고 코드 구현에서도 고려할 것이 많아진다.
 - 도메인 객체가 현실에 존재하는 모든 상태를 표현할 필요는 없다.

<br/>

## 주요 로직의 테스트 코드는 본인을 살리는 길이다.

 - 요구사항은 수시로 변경된다. 개발자가 가장 두려운 것은 특정 기능을 추가하거나 변경했을 떄 예상하지 못한 버그가 발생하지 않을까 하는 막연한 두려움이다.
 - 이를 막을 수 있는 가장 좋은 방법은 주요 로직에 대한 테스트 코드 작성과 코드 리뷰라고 생각한다.

<br/>

## 우선 목표한 기능이 동작하게끔 구현한 후 작게 작게 리팩토링 하자

 - 깔끔하지만 동작 안하는 코드보다 더럽지만 동작하는 코드가 낫다.
 - 처음부터 깔끔하게 짜려고 노력하지 말고, 우선 기능이 되게끔 구현한 후에 일정 시점마다 리팩토링을 시도하는 것이 좋다.

<br/>

## 무조건 정석대로 구현할 필요는 없다.

 - 약속한 시점에 기능을 런치하는 것이 정말 중요하다.
 - 이런 상황을 맞추기 위해 중복 코드와 하드 코딩이 필요하다면 그렇게 구현해도 된다고 생각한다.
    - 다만, 이러한 구현은 한시적으로만 운영되고 문제 상황이 종료되었다면 정리해야 함을 전제로 한다.

